#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
RELEASE_DIR="${ROOT_DIR}/docs/releases"
APPLICATION_FILE="${ROOT_DIR}/config/application.rb"
DASHDASH_CHANGELOG="${ROOT_DIR}/node_modules/dashdash/CHANGES.md"
GIT_REMOTE="${GIT_REMOTE:-origin}"

usage() {
  cat <<'USAGE'
Usage:
  bin/release_tag <major|minor|patch> [--llm] [--dry-run] [--tag-message TEXT]
  bin/release_tag retag <version> [--tag-message TEXT]

Options:
  --llm      Attempt to draft release notes with the OpenAI API
             (requires OPENAI_API_KEY and curl). Falls back to a
             template when the API call fails.
  --dry-run  Show the calculated version and target file, but do not
             write anything to disk.
  --tag-message
            Override the annotated tag message (defaults to
            "Release vX.Y.Z").
  --help     Display this help text.
USAGE
}

die() {
  echo "release_tag: $*" >&2
  exit 1
}

latest_release_version() {
  local latest_file
  latest_file="$(ls "${RELEASE_DIR}"/v*.md 2>/dev/null | sort -V | tail -n 1 || true)"
  [[ -n "${latest_file}" ]] || die "no releases found under ${RELEASE_DIR}"
  basename "${latest_file%.md}" | sed 's/^v//'
}

increment_version() {
  local current bump
  current="$1"
  bump="$2"
  IFS='.' read -r major minor patch <<<"${current}"
  major=$((10#${major}))
  minor=$((10#${minor}))
  patch=$((10#${patch}))
  case "${bump}" in
    major)
      printf '%d.0.0' "$((major + 1))"
      ;;
    minor)
      printf '%d.%d.0' "${major}" "$((minor + 1))"
      ;;
    patch)
      printf '%d.%d.%d' "${major}" "${minor}" "$((patch + 1))"
      ;;
    *)
      die "unknown bump type: ${bump}"
      ;;
  esac
}

git_log_since() {
  local previous_tag
  previous_tag="v$1"
  if (cd "${ROOT_DIR}" &&
      git rev-parse -q --verify "${previous_tag}" >/dev/null 2>&1); then
    (cd "${ROOT_DIR}" && git log --oneline --no-merges "${previous_tag}..HEAD")
  else
    (cd "${ROOT_DIR}" && git log --oneline --no-merges -n 50)
  fi
}

run_git() {
  (cd "${ROOT_DIR}" && git "$@")
}

ensure_git_available() {
  command -v git >/dev/null || die "git is required"
}

current_branch() {
  run_git rev-parse --abbrev-ref HEAD
}

sanitize_version() {
  local input="$1"
  if [[ "${input}" =~ ^v?([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
    printf '%s' "${BASH_REMATCH[1]}"
  else
    die "invalid version string: ${input}"
  fi
}

stage_release_artifacts() {
  local file
  for file in "${TARGET_FILE}" "${APPLICATION_FILE}" "${DASHDASH_CHANGELOG}"; do
    if run_git check-ignore -q -- "${file}"; then
      # Force-add ignored paths like node_modules/dashdash/CHANGES.md.
      run_git add -f -- "${file}"
    else
      run_git add -- "${file}"
    fi
  done
}

commit_release_artifacts() {
  local message
  message="$1"
  if run_git diff --cached --quiet; then
    die "no staged changes to commit for ${message}"
  fi
  run_git commit -m "${message}"
}

tag_release_ref() {
  local tag message
  tag="$1"
  message="$2"
  run_git tag -fa "${tag}" -m "${message}"
}

push_release_commit_and_tag() {
  local tag branch
  tag="$1"
  branch="$(current_branch)"
  [[ "${branch}" != "HEAD" ]] || die "cannot push from detached HEAD"
  run_git push "${GIT_REMOTE}" "${branch}"
  run_git push --force "${GIT_REMOTE}" "refs/tags/${tag}"
  printf '%s' "${branch}"
}

update_release_env_assignment() {
  local file version
  file="${APPLICATION_FILE}"
  version="v${NEW_VERSION}"
  [[ -f "${file}" ]] || \
    die "missing release assignment file: ${file}"
  FILE="${file}" VERSION="${version}" ruby <<'RUBY'
file = ENV.fetch('FILE')
version = ENV.fetch('VERSION')
content = File.read(file)
pattern = /(ENV\['RELEASE'\]\s*=\s*')v?\d+\.\d+\.\d+('.*)/
abort "ENV['RELEASE'] assignment not found in #{file}" unless \
  content.match?(pattern)
updated = content.sub(pattern) { "#{$1}#{version}#{$2}" }
File.write(file, updated)
RUBY
}

append_dashdash_changelog() {
  local file
  file="${DASHDASH_CHANGELOG}"
  [[ -f "${file}" ]] || \
    die "missing dashdash changelog: ${file}"
  {
    printf '\n## v%s\n\n' "${NEW_VERSION}"
    printf '%s\n\n' "${EXEC_SUMMARY}"
    printf '%s\n' "${CHANGES}"
  } >>"${file}"
}

llm_release_notes() {
  local version commit_log payload response content
  version="$1"
  commit_log="$2"
  [[ -n "${OPENAI_API_KEY:-}" ]] || die "OPENAI_API_KEY must be set for --llm"
  command -v curl >/dev/null || die "curl is required for --llm"
  payload="$(
    VERSION="${version}" COMMITS="${commit_log}" ruby <<'RUBY'
require 'json'
version = ENV.fetch('VERSION')
commits = ENV.fetch('COMMITS')
prompt = <<~PROMPT
  Write release notes for #{version} based only on these commits:
  #{commits}
  Respond in this exact format:
  SUMMARY: <single paragraph>
  CHANGES:
  - bullet one
  - bullet two
PROMPT
body = {
  model: 'gpt-4o-mini',
  temperature: 0.2,
  messages: [
    { role: 'system',
      content: 'You create terse, accurate release notes for engineers.' },
    { role: 'user', content: prompt }
  ]
}
puts JSON.dump(body)
RUBY
  )"
  response="$(
    curl -sS -X POST https://api.openai.com/v1/chat/completions \
      -H "Authorization: Bearer ${OPENAI_API_KEY}" \
      -H "Content-Type: application/json" \
      -d "${payload}"
  )" || die "failed to contact OpenAI API"
  content="$(
    RESPONSE_PAYLOAD="${response}" ruby <<'RUBY'
require 'json'
input = JSON.parse(ENV.fetch('RESPONSE_PAYLOAD'))
choice = input.fetch('choices').fetch(0, {})
message = choice.fetch('message', {})
puts message.fetch('content', '').strip
RUBY
  )"
  [[ -n "${content}" ]] || die "OpenAI response missing content"
  printf '%s\n' "${content}"
}

write_release_template() {
  local file exec_summary changes commit_log
  file="$1"
  exec_summary="$2"
  changes="$3"
  commit_log="$4"
  cat >"${file}" <<EOF
# v${NEW_VERSION}

${exec_summary}

## Changes

${changes}

## Recent commits (for reference)

\`\`\`
${commit_log}
\`\`\`

## GitHub release checklist

1. Copy these notes into the GitHub release description.
2. Verify tag v${NEW_VERSION} exists on origin (\`git fetch --tags\`).
3. Announce the release internally.
EOF
}

[[ $# -ge 1 ]] || { usage >&2; exit 1; }

BUMP_TYPE=""
USE_LLM=0
DRY_RUN=0
MODE="bump"
RETAG_VERSION=""
TAG_MESSAGE_OVERRIDE=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    major|minor|patch)
      [[ -z "${BUMP_TYPE}" ]] || die "bump type already specified"
      [[ "${MODE}" != "retag" ]] || die "cannot combine bump and retag"
      BUMP_TYPE="$1"
      shift
      ;;
    retag)
      [[ -z "${RETAG_VERSION}" ]] || die "retag already specified"
      MODE="retag"
      shift
      [[ $# -gt 0 ]] || die "retag requires a version argument"
      RETAG_VERSION="$1"
      shift
      ;;
    --tag-message)
      shift
      [[ $# -gt 0 ]] || die "--tag-message requires a value"
      TAG_MESSAGE_OVERRIDE="$1"
      shift
      ;;
    --llm)
      [[ "${MODE}" == "bump" ]] || die "--llm is unavailable for retag"
      USE_LLM=1
      shift
      ;;
    --dry-run)
      [[ "${MODE}" == "bump" ]] || die "--dry-run is unavailable for retag"
      DRY_RUN=1
      shift
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    *)
      die "unknown argument: $1"
      ;;
  esac
done

if [[ "${MODE}" == "retag" ]]; then
  [[ -n "${RETAG_VERSION}" ]] || { usage >&2; exit 1; }
  [[ -z "${BUMP_TYPE}" ]] || die "cannot specify bump type with retag"
  ensure_git_available
  [[ -d "${RELEASE_DIR}" ]] || die "missing release directory: ${RELEASE_DIR}"
  NEW_VERSION="$(sanitize_version "${RETAG_VERSION}")"
  TAG_NAME="v${NEW_VERSION}"
  TAG_MESSAGE="${TAG_MESSAGE_OVERRIDE:-"Release ${TAG_NAME}"}"
  [[ -f "${RELEASE_DIR}/${TAG_NAME}.md" ]] || \
    die "release notes ${RELEASE_DIR}/${TAG_NAME}.md not found"
  tag_release_ref "${TAG_NAME}" "${TAG_MESSAGE}"
  BRANCH_PUSHED="$(push_release_commit_and_tag "${TAG_NAME}")"
  cat <<EOF
Retagged ${TAG_NAME} to HEAD on branch ${BRANCH_PUSHED} and pushed to ${GIT_REMOTE}.

Tag message:
${TAG_MESSAGE}
EOF
  exit 0
fi

[[ -n "${BUMP_TYPE}" ]] || { usage >&2; exit 1; }
[[ -d "${RELEASE_DIR}" ]] || die "missing release directory: ${RELEASE_DIR}"

CURRENT_VERSION="$(latest_release_version)"
NEW_VERSION="$(increment_version "${CURRENT_VERSION}" "${BUMP_TYPE}")"
TAG_NAME="v${NEW_VERSION}"
COMMIT_MESSAGE="Release ${TAG_NAME}"
TAG_MESSAGE="${TAG_MESSAGE_OVERRIDE:-${COMMIT_MESSAGE}}"
TARGET_FILE="${RELEASE_DIR}/v${NEW_VERSION}.md"

if [[ "${DRY_RUN}" -eq 1 ]]; then
  cat <<EOF
Current version: v${CURRENT_VERSION}
Next version   : v${NEW_VERSION}
Target file    : ${TARGET_FILE}
EOF
  exit 0
fi

ensure_git_available
[[ ! -e "${TARGET_FILE}" ]] || die "release file already exists: ${TARGET_FILE}"

COMMIT_LOG="$(git_log_since "${CURRENT_VERSION}")"

EXEC_SUMMARY="TODO: Add a 1-2 sentence executive summary for v${NEW_VERSION}."
CHANGES="- TODO: List notable changes."

if [[ "${USE_LLM}" -eq 1 ]]; then
  if CONTENT="$(llm_release_notes "v${NEW_VERSION}" "${COMMIT_LOG}")"; then
    SUMMARY_LINE="$(
      printf '%s\n' "${CONTENT}" |
        awk '/^SUMMARY:/ {sub(/^SUMMARY:[[:space:]]*/, ""); print; exit}'
    )"
    CHANGE_LINES="$(
      printf '%s\n' "${CONTENT}" |
        awk 'BEGIN{capture=0}
             /^CHANGES:/ {capture=1; next}
             { if (capture) print }'
    )"
    if [[ -n "${SUMMARY_LINE}" ]]; then
      EXEC_SUMMARY="${SUMMARY_LINE}"
    fi
    if [[ -n "${CHANGE_LINES}" ]]; then
      CHANGES="${CHANGE_LINES}"
    fi
  else
    echo "release_tag: falling back to template after LLM failure" >&2
  fi
fi

write_release_template "${TARGET_FILE}" "${EXEC_SUMMARY}" "${CHANGES}" "${COMMIT_LOG}"
append_dashdash_changelog
update_release_env_assignment
stage_release_artifacts
commit_release_artifacts "${COMMIT_MESSAGE}"
tag_release_ref "${TAG_NAME}" "${TAG_MESSAGE}"
BRANCH_PUSHED="$(push_release_commit_and_tag "${TAG_NAME}")"

cat <<EOF
Created ${TARGET_FILE}
Committed and pushed ${COMMIT_MESSAGE} on branch ${BRANCH_PUSHED}.
Tag ${TAG_NAME} pushed (force-updated) to ${GIT_REMOTE}.

Next steps:
  - Populate the summary and change list (or rerun with --llm).
  - Review node_modules/dashdash/CHANGES.md for the appended entry.
  - Publish the GitHub release using docs/releases/${TAG_NAME}.md.
EOF

